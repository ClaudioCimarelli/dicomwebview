<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>DICOM viewer</title>
    <link rel="stylesheet" href='{{ url_for('static',filename='style.css') }}'>
    <script src="{{ url_for('static', filename='vue.js') }}"></script>
    <script src="{{ url_for('static', filename='jquery-3.2.1.js') }}"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
</head>
<body>


<div id="app">
    <component is="slices" :planes="planes"></component>
</div>


<template id="slices-templ">
    <div>
        <div>
            <input id="canvas_box_size-slider'" type="range" v-model="canvas_box_size"
                   min="600"
                   max="1200"/>
        </div>
        <div id="slices">
            <component is="slice" v-for="plane in planes" :key="plane.id" :plane="plane"
                       :canvas_box_size="canvas_box_size">
            </component>
        </div>
    </div>
</template>

<template id="slice-templ">
    <div :id="plane.name" class="slice-box">
        <div class="canvas-box" :style="{ width: canvas_box_size + 'px', height: canvas_box_size + 'px'}">
            <canvas :id="plane.name + '-image'"
                    style="position: absolute; left: 0; top: 0; z-index: 0;"
                    :height="scaled_height + 'px'"
                    :width="scaled_width + 'px'">
            </canvas>
            <canvas id="display-canv"
                    style="position: absolute; left: 0; top: 0; z-index: 0;"
                    :height="scaled_height + 'px'"
                    :width="scaled_width + 'px'">
            </canvas>
            <component is="segmentation" v-if="plane.name=='axial'" v-for="z in _.range(5)" :key="z"
                       :plane-name="plane.name"
                       :scaled-height="scaled_height" :scaled-width="scaled_width"
                       :zoom="zoom" :z="z+1"
                       :display-canvas="display_canv">
            </component>
        </div>
        <span>slice number: ${slice_number}</span>
        <input :id="plane.name + '-slider'" type="range" v-model="slice_number"
               min="0"
               :max="plane.z"/>
        <span>zoom: ${zoom}</span>
        <input id="canvas_size-slider'" type="range" v-model="scaled_height"
               :min="plane.y"
               :max="plane.y*3"
               :step="plane.y/2"/>
    </div>
</template>

<template id="segmentation-template">
    <canvas v-show="display" :id="planeName + '-segmentation'+z"
            style="position: absolute; left: 0; top: 0;"
            :z-index="z"
            @mousemove="get_coordinates"
            @mousedown="drawing = true"
            @mouseup="drawing = false">
    </canvas>
</template>

<script>

    var scaling_bus = new Vue()

    var segmentation_component = {
        template: '#segmentation-template',
        delimiters: ['${', '}'],
        props: ['displayCanvas', 'planeName', 'scaledWidth', 'scaledHeight', 'zoom', 'z'],
        data() {
            return {
                'segm_canv': null,
                'segm_ctx': null,
                'cursor': {
                    x: 0,
                    y: 0
                },
                'drawing': false,
                'color': "yellow",
                'draw_enabled': true
            }
        },
        computed: {
            zoomLevel() {
                return this.zoom * 2 - 1
            },
            display() {
                return this.zoomLevel == this.z
            }
        },
        mounted() {
            this.segm_canv = document.getElementById(this.planeName + '-segmentation' + this.z)
            this.segm_canv.width = this.scaledWidth * (this.z + 1) / 2
            this.segm_canv.height = this.scaledHeight * (this.z + 1) / 2

            this.segm_ctx = this.segm_canv.getContext("2d")
            this.segm_ctx.beginPath()
            this.segm_ctx.strokeStyle = this.color

            for (x in _.range(5)) {
                if ((parseInt(x) + 1) != this.z) {
                    var self = this
                    scaling_bus.$on('scaling' + (parseInt(x) + 1), function (layerZ, image) {
                        if (self.display) {
                            let ctx = self.displayCanvas.getContext("2d")
                            ctx.imageSmoothingEnabled = false
                            ctx.mozImageSmoothingEnabled = false
                            ctx.webkitImageSmoothingEnabled = false
                            ctx.msImageSmoothingEnabled = false
                            ctx.drawImage(image, 0, 0, self.segm_canv.width, self.segm_canv.height)
                        }
                    })
                }
            }
        },
        updated() {
        },
        methods: {
            get_coordinates(event) {
                {#let rect = this.canvas.getBoundingClientRect();
                console.log("x: %d, y: %d", event.clientX- rect.left, event.clientY- rect.top)#}
                this.cursor = {
                    x: event.layerX,
                    y: event.layerY
                }
            }
        },
        watch: {
            cursor() {
                if (this.drawing) {
                    this.segm_ctx.lineTo(this.cursor.x, this.cursor.y)
                    this.segm_ctx.stroke()
                }
            },
            zoomLevel() {
                if (!this.display) {
                    let image = cloneCanvas(this.segm_canv)
                    scaling_bus.$emit('scaling' + this.z, this.z, image)
                }
            },
            drawing() {
                if (this.drawing) {
                    this.segm_ctx.moveTo(this.cursor.x, this.cursor.y)
                }
            },
            color() {
                this.segm_ctx.strokeStyle = this.color
            }
        }
    }

    function cloneCanvas(oldCanvas) {

        //create a new canvas
        let newCanvas = document.createElement('canvas')
        let context = newCanvas.getContext('2d')

        //set dimensions
        newCanvas.width = oldCanvas.width
        newCanvas.height = oldCanvas.height

        //apply the old canvas to the new one
        context.drawImage(oldCanvas, 0, 0);

        //return the new canvas
        return newCanvas;
    }


    var slices = {
        template: '#slice-templ',
        delimiters: ['${', '}'],
        props: ['plane', 'canvas_box_size'],
        data() {
            return {
                'slice_number': 0,
                'image_url': null,
                'canvas': null,
                'display_canv': null,
                'ctx': null,
                'scaled_height': this.plane.y
            }
        },
        components: {
            'segmentation': segmentation_component
        },
        computed: {
            zoom() {
                return this.scaled_height / this.plane.y
            },
            scaled_width() {
                let real_width = Math.floor(this.plane.x * this.plane.ratio)
                let scaled_width = Math.floor(real_width * this.scaled_height / this.plane.y)
                return scaled_width
            }
        },
        mounted() {
            this.canvas = document.getElementById(this.plane.name + '-image')
            this.ctx = this.canvas.getContext("2d")

            this.display_canv = document.getElementById("display-canv")
            this.display_canv.style.imageRendering = 'pixelated'

            this.slice_number = Math.floor(this.plane.z / 2)
        },
        methods: {
            fetch_slice() {
                var self = this
                fetch(`api/0/stored_dicom/get_slice/${this.plane.name}/${this.slice_number}`)
                    .then((res) => {
                        if (!res.ok) {
                            console.warn(res)
                            return
                        }
                        return res.blob();
                    })
                    .then(function (myBlob) {
                        let img = new Image();
                        img.onload = function () {
                            self.ctx.drawImage(img, 0, 0, self.scaled_width, self.scaled_height)
                        }
                        let objectURL = URL.createObjectURL(myBlob)
                        img.src = objectURL
                        self.image_url = objectURL
                    })
                    .catch((err) => {
                        console.warn(err)
                    })
            }
        },
        watch: {
            slice_number() {
                this.fetch_slice()
            },
            scaled_width() {
                let img = new Image();
                let self = this
                img.onload = function () {
                    self.ctx.drawImage(img, 0, 0, self.scaled_width, self.scaled_height)
                }
                img.src = this.image_url
            }
        }
    }

    var slices_container = {
        template: '#slices-templ',
        delimiters: ['${', '}'],
        props: ['planes'],
        components: {
            'slice': slices
        },
        data() {
            return {
                'canvas_box_size': 700
            }
        }

    }

    var app = new Vue({
        el: '#app',
        delimiters: ['${', '}'],
        data: {
            planes: [
                {
                    id: 0,
                    name: 'axial',
                    z: {{ session['dimension'][0] - 1}},
                    x: {{ session['dimension'][1]}},
                    y: {{ session['dimension'][2]}},
                    ratio: {{ session['ratios'][0] }}
                },
                {
                    id: 2,
                    name: 'sagittal',
                    z: {{ session['dimension'][2] - 1}},
                    x: {{ session['dimension'][2]}},
                    y: {{ session['dimension'][0]}},
                    ratio: {{ session['ratios'][2] }}

                },
                {
                    id: 1,
                    name: 'coronal',
                    z: {{ session['dimension'][1] - 1}},
                    x: {{ session['dimension'][1]}},
                    y: {{ session['dimension'][0]}},
                    ratio: {{ session['ratios'][1] }}
                }
            ]
        },
        components: {
            'slices': slices_container
        }
    })


</script>

</body>
</html>